
配置数据层
    版本号、源站地址、正式保存地址、临时保存地址、并发数

用户层
    对外暴露的API，接收用户的请求下载、取消下载。收到请求下载后返回一个Operation标记，需要用户使用Operation标记来取消下载。

请求层
    为了应多用户对同一文件的重复请求，或者用户发出了大量请求，在这里做了一个缓冲层，使用Request轻量级数据对象来包装用户的请求下载。
    一个文件对应一个Request对象，重复下载时只有一个Request对象，其内部维护了下载Operation，一个uuid对应一个operation。
    当收到请求时，调度器会识别是否是重复任务，如果是新任务则创建Request对象，如果是已有任务则刷新Request对象时间戳并加入Operation维护，
    如果是取消下载把Request对象的内部Operation移除回收，如果没有Operation了，就给Request打上取消标记方便调度层筛查，同时1分钟后取消(避免频繁删除创建对象)
    在Unity主线程计算，筛查激活状态的和最新时间戳的Request对象推送给任务层开始处理下载

任务层
    接收到Request下载请求，创建Task对象并维护下载上下文Context
    Context数据优先检查本地临时保存地址下，是否是同版本号的，且断点续传对象Info是否存在的，如果满足两个条件就反序列化Info数据构建Context，如果不满足就从源站获取文件信息构建Context
    如果从源站数据构建Context数据，。。。，推送给下载层

下载层
    根据Context创建下载管理Manager对象和下载并发Segment对象，每个Segment对象有inStream、outStream、保存地址，Manager对象根据Segment数据负责更新Context
    需要一个专门调度Segment的链接调度器
    需要一个专门调度Segment的读写调度器
    
推送下载逻辑更新
    用户层发出请求下载，附带资源名、优先级
    如果该资源是首次请求，就是创建request对象
        如果是低优先级刷新为silent模式
        如果是高优先级刷新为manual模式
    如果该资源是重复请求，只是刷新hotTime和优先级
    两种方式，刷新之后等待任务层根据hotTime和优先级调度最适合的request推送给任务层

取消下载逻辑更新
    用户层发出取消下载之后，请求层取消下载的是该次收到的uuid，一个uuid对应一个operation。
    请求层取消operation之后，该请求降级为silent模式并刷新hotTime，
    如果这个请求已经被推送给了任务层，需要等待任务层去执行下载完毕，只是不会通知用户该资源下载完成
    如果这个请求还未推送给任务层，也只是取消掉operation回调并降级和刷新时间
    

更新断点下载恢复逻辑
    之前想到使用序列化信息恢复断点续传，但是遇到极端情况、异常退出导致信息丢失或者不完整，风险较大。现在使用分段名包含必要信息，只需要检测版本号一致，合并后的md5一致。
    // 分段文件命名格式：{fileName}.seg{index}.{startPos}-{endPos}.tmp
    // 示例：test.bundle.seg0.0-1048575.tmp
    //      test.bundle.seg1.1048576-2097151.tmp

|方案｜缺点｜风险|
|------|------|------|------|
|序列化信息|崩溃异常退出、信息不完整|高|
|文件名包含|版本不一致|低|


